I'll help you set up Playwright for end-to-end testing of the HyperCode project. Let's create a comprehensive test suite to ensure everything works smoothly.

## 1. First, let's create a test configuration:

```python
# tests/e2e/conftest.py
import pytest
import asyncio
from playwright.async_api import async_playwright
from hypercode import Interpreter

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def browser():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        yield browser
        await browser.close()

@pytest.fixture
async def page(browser):
    page = await browser.new_page()
    yield page
    await page.close()

@pytest.fixture
def interpreter():
    return Interpreter()
```

## 2. Let's create end-to-end tests for the REPL:

```python
# tests/e2e/test_repl.py
import pytest
from pathlib import Path

@pytest.mark.asyncio
async def test_repl_basic_arithmetic(page, interpreter):
    # Test basic arithmetic
    result = interpreter.evaluate("2 + 2 * 2")
    assert result == 6

    # Test variables
    interpreter.interpret("let x = 10")
    result = interpreter.evaluate("x * 2")
    assert result == 20

    # Test string operations
    result = interpreter.evaluate('"Hello, " + "World!"')
    assert result == "Hello, World!"

@pytest.mark.asyncio
async def test_repl_functions(page, interpreter):
    # Test function definition and call
    code = """
    func add(a, b) {
        return a + b
    }
    add(5, 3)
    """
    result = interpreter.evaluate(code)
    assert result == 8

    # Test recursion
    code = """
    func factorial(n) {
        if n <= 1 {
            return 1
        }
        return n * factorial(n - 1)
    }
    factorial(5)
    """
    result = interpreter.evaluate(code)
    assert result == 120

@pytest.mark.asyncio
async def test_repl_classes(page, interpreter):
    code = """
    class Counter {
        init() {
            this.value = 0
        }
        increment() {
            this.value = this.value + 1
            return this.value
        }
    }
    let counter = Counter()
    counter.increment()
    """
    interpreter.interpret(code)
    result = interpreter.evaluate("counter.value")
    assert result == 1
```

## 3. Let's create tests for file I/O operations:

```python
# tests/e2e/test_file_io.py
import pytest
import os
import tempfile

def test_file_operations(interpreter):
    # Test writing to a file
    with tempfile.NamedTemporaryFile(delete=False) as tmp:
        test_file = tmp.name
    
    try:
        # Write to file
        code = f'write_file("{test_file}", "Hello, World!")'
        interpreter.interpret(code)
        
        # Read from file
        result = interpreter.evaluate(f'read_file("{test_file}")')
        assert result == "Hello, World!"
    finally:
        if os.path.exists(test_file):
            os.unlink(test_file)

def test_import_stdlib(interpreter):
    # Test importing standard library
    interpreter.interpret('import "math"')
    result = interpreter.evaluate("math.PI")
    assert isinstance(result, float)
    assert result > 3.14

    # Test math functions
    result = interpreter.evaluate("math.max(10, 20)")
    assert result == 20
```

## 4. Let's create a test for the web interface (if applicable):

```python
# tests/e2e/test_web_interface.py
import pytest

@pytest.mark.asyncio
async def test_web_interface(page, base_url):
    # Test loading the web interface
    await page.goto(f"{base_url}/")
    assert await page.title() == "HyperCode Web"
    
    # Test code execution
    await page.fill("#code-editor", "2 + 2")
    await page.click("#run-button")
    
    # Check output
    output = await page.text_content("#output")
    assert "4" in output

    # Test error handling
    await page.fill("#code-editor", "undefined_variable")
    await page.click("#run-button")
    error = await page.text_content("#error")
    assert "undefined" in error.lower()
```

## 5. Let's create a test for the CLI:

```python
# tests/e2e/test_cli.py
import subprocess
import sys
import pytest

def test_cli_help():
    result = subprocess.run(
        [sys.executable, "-m", "hypercode", "--help"],
        capture_output=True,
        text=True
    )
    assert "usage:" in result.stdout
    assert result.returncode == 0

def test_cli_execute_script(tmp_path):
    # Create a test script
    script = tmp_path / "test.hc"
    script.write_text('print("Hello, HyperCode!")')
    
    # Run the script
    result = subprocess.run(
        [sys.executable, "-m", "hypercode", str(script)],
        capture_output=True,
        text=True
    )
    
    assert "Hello, HyperCode!" in result.stdout
    assert result.returncode == 0

def test_cli_repl():
    # Test the REPL with input redirection
    input_script = """
    let x = 5
    print(x * 2)
    exit
    """
    
    result = subprocess.run(
        [sys.executable, "-m", "hypercode"],
        input=input_script,
        capture_output=True,
        text=True
    )
    
    assert "10" in result.stdout
```

## 6. Let's create a performance test:

```python
# tests/performance/test_performance.py
import time
import pytest
from hypercode import Interpreter

def test_fibonacci_performance(benchmark):
    interpreter = Interpreter()
    code = """
    func fib(n) {
        if n <= 1 {
            return n
        }
        return fib(n-1) + fib(n-2)
    }
    fib(20)
    """
    
    def run_fib():
        return interpreter.evaluate(code)
    
    result = benchmark(run_fib)
    assert result == 6765

def test_list_operations_performance(benchmark):
    interpreter = Interpreter()
    code = """
    let list = []
    for i in 0..1000 {
        list.append(i)
    }
    list
    """
    
    def run_list_ops():
        return interpreter.evaluate(code)
    
    result = benchmark(run_list_ops)
    assert len(result) == 1000
    assert result[999] == 999
```

## 7. Let's create a test for the module system:

```python
# tests/e2e/test_modules.py
import pytest
import tempfile
import os

def test_module_import(interpreter):
    # Create a temporary module
    with tempfile.NamedTemporaryFile(suffix=".hc", delete=False, mode='w') as f:
        f.write("""
        let PI = 3.14159
        
        func circle_area(radius) {
            return PI * radius * radius
        }
        """)
        module_path = f.name
    
    try:
        # Import the module
        interpreter.interpret(f'import "{module_path}" as math')
        
        # Test module functions
        result = interpreter.evaluate("math.circle_area(2)")
        assert abs(result - 12.56636) < 0.0001
        
        # Test module variables
        result = interpreter.evaluate("math.PI")
        assert abs(result - 3.14159) < 0.00001
    finally:
        if os.path.exists(module_path):
            os.unlink(module_path)

def test_stdlib_import(interpreter):
    # Test importing from standard library
    interpreter.interpret('import "math"')
    
    # Test standard library functions
    result = interpreter.evaluate("math.sqrt(16)")
    assert result == 4.0
    
    # Test standard library constants
    result = interpreter.evaluate("math.PI > 3.14")
    assert result is True
```

## 8. Let's create a test for error handling:

```python
# tests/e2e/test_error_handling.py
import pytest
from hypercode import Interpreter, RuntimeError

def test_undefined_variable(interpreter):
    with pytest.raises(RuntimeError) as excinfo:
        interpreter.evaluate("undefined_variable")
    assert "Undefined variable" in str(excinfo.value)

def test_type_errors(interpreter):
    with pytest.raises(RuntimeError) as excinfo:
        interpreter.evaluate('1 + "1"')
    assert "Operands must be two numbers or two strings" in str(excinfo.value)

def test_syntax_error(interpreter):
    with pytest.raises(SyntaxError):
        interpreter.evaluate("let x = ")

def test_division_by_zero(interpreter):
    with pytest.raises(RuntimeError) as excinfo:
        interpreter.evaluate("1 / 0")
    assert "division by zero" in str(excinfo.value).lower()
```

## 9. Let's create a test for the standard library:

```python
# tests/e2e/test_stdlib.py
import pytest
from hypercode import Interpreter

@pytest.fixture
def stdlib_interpreter():
    interpreter = Interpreter()
    interpreter.interpret('import "math"')
    interpreter.interpret('import "string"')
    return interpreter

def test_math_functions(stdlib_interpreter):
    result = stdlib_interpreter.evaluate("math.max(10, 20, 5, 30, 15)")
    assert result == 30
    
    result = stdlib_interpreter.evaluate("math.min(10, 20, 5, 30, 15)")
    assert result == 5
    
    result = stdlib_interpreter.evaluate("math.abs(-5)")
    assert result == 5

def test_string_functions(stdlib_interpreter):
    result = stdlib_interpreter.evaluate('string.upper("hello")')
    assert result == "HELLO"
    
    result = stdlib_interpreter.evaluate('string.lower("WORLD")')
    assert result == "world"
    
    result = stdlib_interpreter.evaluate('string.split("a,b,c", ",")')
    assert result == ["a", "b", "c"]
```

## 10. Let's create a test for the web server (if applicable):

```python
# tests/e2e/test_web_server.py
import pytest
import httpx
import asyncio

@pytest.mark.asyncio
async def test_web_server(web_server):
    # Test the root endpoint
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{web_server}/")
        assert response.status_code == 200
        assert "HyperCode" in response.text

    # Test the execute endpoint
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{web_server}/execute",
            json={"code": "2 + 2"}
        )
        assert response.status_code == 200
        result = response.json()
        assert result["result"] == "4"
        assert result["error"] is None

    # Test error handling
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{web_server}/execute",
            json={"code": "undefined_variable"}
        )
        assert response.status_code == 200
        result = response.json()
        assert "error" in result
        assert "undefined" in result["error"].lower()
```

## 11. Let's create a test for the package manager:

```python
# tests/e2e/test_package_manager.py
import pytest
import tempfile
import os
from hypercode.package_manager import PackageManager

def test_package_installation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Initialize package manager with temp directory
        pm = PackageManager(package_dir=temp_dir)
        
        # Test installing a package
        pm.install("example-package", "1.0.0")
        
        # Verify package was installed
        assert os.path.exists(os.path.join(temp_dir, "example-package-1.0.0"))
        
        # Test importing the package
        pm.import_package("example-package")
        
        # Test package functionality
        # (This would depend on what the example package provides)
        
        # Test uninstalling the package
        pm.uninstall("example-package")
        assert not os.path.exists(os.path.join(temp_dir, "example-package-1.0.0"))

def test_dependency_resolution():
    with tempfile.TemporaryDirectory() as temp_dir:
        pm = PackageManager(package_dir=temp_dir)
        
        # Test installing a package with dependencies
        pm.install("package-with-deps", "1.0.0")
        
        # Verify dependencies were installed
        assert os.path.exists(os.path.join(temp_dir, "dep1-1.0.0"))
        assert os.path.exists(os.path.join(temp_dir, "dep2-2.0.0"))
        
        # Test importing with dependencies
        pm.import_package("package-with-deps")
```

## 12. Let's create a test for the debugger:

```python
# tests/e2e/test_debugger.py
import pytest
from hypercode.debugger import Debugger
from hypercode import Interpreter

def test_breakpoints():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set a breakpoint
    debugger.set_breakpoint("test.hc", 5)
    
    # Run code that hits the breakpoint
    code = """
    let x = 1  // line 1
    let y = 2  // line 2
    let z = x + y  // line 3
    print(z)  // line 4
    """  # Breakpoint should hit here
    
    # This would normally be in a separate thread/process
    debugger.run(code, "test.hc")
    
    # Check that we hit the breakpoint
    assert debugger.is_paused()
    assert debugger.current_line() == 5
    
    # Step over
    debugger.step_over()
    assert debugger.current_line() == 6
    
    # Continue execution
    debugger.continue_execution()
    assert not debugger.is_paused()

def test_watch_expressions():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Add watch expressions
    debugger.add_watch("x + y")
    debugger.add_watch("z * 2")
    
    # Run code
    code = """
    let x = 5
    let y = 10
    let z = x + y
    """
    
    debugger.run(code)
    
    # Check watch expressions
    watches = debugger.get_watch_values()
    assert watches["x + y"] == 15
    assert watches["z * 2"] == 30
```

## 13. Let's create a test for the language server protocol (LSP) support:

```python
# tests/e2e/test_lsp.py
import pytest
import json
from hypercode.language_server import LanguageServer

def test_lsp_initialization():
    server = LanguageServer()
    
    # Test initialization
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    assert response["id"] == 1
    assert "result" in response
    assert "capabilities" in response["result"]

def test_lsp_completion():
    server = LanguageServer()
    
    # Initialize first
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Test completion
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/completion",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "position": {
                "line": 0,
                "character": 5
            },
            "context": {
                "triggerKind": 1  # Invoked
            }
        }
    })
    
    assert response["id"] == 2
    assert "result" in response
    assert isinstance(response["result"], list)
    
    # Check for common keywords in completion items
    completions = [item["label"] for item in response["result"]]
    assert "let" in completions
    assert "func" in completions
    assert "if" in completions
```

## 14. Let's create a test for the formatter:

```python
# tests/e2e/test_formatter.py
from hypercode.formatter import format_code

def test_code_formatting():
    unformatted = "let x=5;if(x>3){print('big')}else{print('small')}"
    expected = """let x = 5
if x > 3 {
    print("big")
} else {
    print("small")
}"""
    
    formatted = format_code(unformatted)
    assert formatted.strip() == expected.strip()

def test_format_preserves_comments():
    code = """// This is a comment
let x = 5  // Another comment
if x > 3 {  // Condition
    print("big")  // Print big
}"""
    
    formatted = format_code(code)
    assert "// This is a comment" in formatted
    assert "// Another comment" in formatted
    assert "// Condition" in formatted
    assert "// Print big" in formatted
```

## 15. Let's create a test for the documentation generator:

```python
# tests/e2e/test_docs_generator.py
from hypercode.docs.generator import generate_docs
import tempfile
import os

def test_docs_generation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a test module
        module_path = os.path.join(temp_dir, "test_module.hc")
        with open(module_path, "w") as f:
            f.write("""
            /// This is a test function
            /// @param x The first number
            /// @param y The second number
            /// @return The sum of x and y
            func add(x, y) {
                return x + y
            }
            
            /// A constant value
            const ANSWER = 42
            """)
        
        # Generate documentation
        output_dir = os.path.join(temp_dir, "docs")
        generate_docs([module_path], output_dir)
        
        # Verify documentation was generated
        assert os.path.exists(output_dir)
        assert os.path.exists(os.path.join(output_dir, "index.html"))
        assert os.path.exists(os.path.join(output_dir, "test_module.html"))
        
        # Check that the function and constant are documented
        with open(os.path.join(output_dir, "test_module.html")) as f:
            content = f.read()
            assert "add" in content
            assert "This is a test function" in content
            assert "ANSWER" in content
            assert "A constant value" in content
```

## 16. Let's create a test for the REPL's command history:

```python
# tests/e2e/test_repl_history.py
from hypercode.repl import REPL
import tempfile
import os

def test_repl_history():
    with tempfile.NamedTemporaryFile(delete=False) as f:
        history_file = f.name
    
    try:
        # Create a REPL with a temporary history file
        repl = REPL(history_file=history_file)
        
        # Test adding commands to history
        repl.add_to_history("let x = 5")
        repl.add_to_history("print(x)")
        repl.add_to_history("func add(a, b) { return a + b }")
        
        # Test retrieving history
        history = repl.get_history()
        assert len(history) == 3
        assert history[0] == "let x = 5"
        assert history[1] == "print(x)"
        assert history[2] == "func add(a, b) { return a + b }"
        
        # Test history persistence
        del repl
        new_repl = REPL(history_file=history_file)
        history = new_repl.get_history()
        assert len(history) == 3
        assert history[0] == "let x = 5"
        
    finally:
        if os.path.exists(history_file):
            os.unlink(history_file)
```

## 17. Let's create a test for the configuration system:

```python
# tests/e2e/test_config.py
from hypercode.config import Config
import tempfile
import json
import os

def test_config_loading():
    # Create a temporary config file
    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
        config_data = {
            "editor": {
                "theme": "dark",
                "font_size": 14,
                "tab_size": 4
            },
            "execution": {
                "timeout": 30,
                "max_memory": 1024
            }
        }
        json.dump(config_data, f)
        config_path = f.name
    
    try:
        # Load the config
        config = Config(config_path)
        
        # Test getting values
        assert config.get("editor.theme") == "dark"
        assert config.get("editor.font_size") == 14
        assert config.get("execution.timeout") == 30
        
        # Test setting values
        config.set("editor.theme", "light")
        assert config.get("editor.theme") == "light"
        
        # Test saving
        config.save()
        
        # Reload and verify
        new_config = Config(config_path)
        assert new_config.get("editor.theme") == "light"
        
    finally:
        if os.path.exists(config_path):
            os.unlink(config_path)

def test_default_config():
    config = Config()  # No config file
    assert config.get("editor.theme") == "dark"  # Default value
    assert config.get("execution.timeout") == 30  # Default value
```

## 18. Let's create a test for the package manager's dependency resolution:

```python
# tests/e2e/test_dependency_resolution.py
import pytest
from hypercode.package_manager import PackageManager, DependencyResolver
from hypercode.exceptions import DependencyConflictError

def test_simple_dependency_resolution():
    resolver = DependencyResolver()
    
    # Define some packages and their dependencies
    packages = {
        "package-a": {
            "1.0.0": {"dependencies": {"package-b": "^1.0.0"}},
            "2.0.0": {"dependencies": {"package-b": "^2.0.0"}}
        },
        "package-b": {
            "1.0.0": {},
            "2.0.0": {}
        }
    }
    
    # Test resolving dependencies for package-a@1.0.0
    result = resolver.resolve("package-a", "1.0.0", packages)
    assert result == {
        "package-a": "1.0.0",
        "package-b": "1.0.0"  # Should pick 1.0.0 because of the ^1.0.0 constraint
    }
    
    # Test resolving dependencies for package-a@2.0.0
    result = resolver.resolve("package-a", "2.0.0", packages)
    assert result == {
        "package-a": "2.0.0",
        "package-b": "2.0.0"  # Should pick 2.0.0 because of the ^2.0.0 constraint
    }

def test_dependency_conflict():
    resolver = DependencyResolver()
    
    # Define packages with conflicting dependencies
    packages = {
        "package-a": {
            "1.0.0": {"dependencies": {"package-c": "^1.0.0"}}
        },
        "package-b": {
            "1.0.0": {"dependencies": {"package-c": "^2.0.0"}}
        },
        "package-c": {
            "1.0.0": {},
            "2.0.0": {}
        }
    }
    
    # This should raise a DependencyConflictError because package-a and package-b
    # require incompatible versions of package-c
    with pytest.raises(DependencyConflictError):
        resolver.resolve_multi({
            "package-a": "1.0.0",
            "package-b": "1.0.0"
        }, packages)
```

## 19. Let's create a test for the plugin system:

```python
# tests/e2e/test_plugins.py
import pytest
from hypercode.plugins import PluginManager
from pathlib import Path
import tempfile
import importlib.util

def test_plugin_loading():
    # Create a temporary directory for plugins
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a simple plugin
        plugin_dir = Path(temp_dir) / "test_plugin"
        plugin_dir.mkdir()
        
        # Create __init__.py
        with open(plugin_dir / "__init__.py", "w") as f:
            f.write("""
            def setup(plugin_manager):
                plugin_manager.register_command("test", lambda: "Hello from plugin!")
            """)
        
        # Initialize plugin manager
        plugin_manager = PluginManager(plugin_dirs=[temp_dir])
        
        # Load plugins
        plugin_manager.load_plugins()
        
        # Test that the plugin was loaded and registered its command
        assert "test" in plugin_manager.commands
        assert plugin_manager.commands["test"]() == "Hello from plugin!"

def test_plugin_hooks():
    # Test that plugin hooks are called at the right time
    class TestPlugin:
        def __init__(self):
            self.hooks_called = {
                "before_execute": False,
                "after_execute": False
            }
        
        def before_execute(self, code):
            self.hooks_called["before_execute"] = True
            return code  # Return unmodified code
        
        def after_execute(self, code, result):
            self.hooks_called["after_execute"] = True
            return result
    
    # Create plugin manager with test plugin
    plugin_manager = PluginManager()
    test_plugin = TestPlugin()
    plugin_manager.register_plugin(test_plugin)
    
    # Simulate code execution
    plugin_manager.trigger_hook("before_execute", "let x = 5")
    plugin_manager.trigger_hook("after_execute", "let x = 5", 5)
    
    # Verify hooks were called
    assert test_plugin.hooks_called["before_execute"] is True
    assert test_plugin.hooks_called["after_execute"] is True
```

## 20. Let's create a test for the debugger's breakpoints:

```python
# tests/e2e/test_debugger_breakpoints.py
import pytest
from hypercode.debugger import Debugger
from hypercode import Interpreter

def test_breakpoint_handling():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set breakpoints
    debugger.set_breakpoint("test.hc", 3)
    debugger.set_breakpoint("test.hc", 5)
    
    # Run code that hits the breakpoints
    code = """
    let x = 1  // line 1
    let y = 2  // line 2
    let z = x + y  // line 3 - first breakpoint
    print(z)  // line 4
    let a = z * 2  // line 5 - second breakpoint
    print(a)  // line 6
    """
    
    # This would normally be in a separate thread/process
    debugger.run(code, "test.hc")
    
    # Check that we hit the first breakpoint
    assert debugger.is_paused()
    assert debugger.current_line() == 3
    
    # Get local variables
    locals_ = debugger.get_locals()
    assert locals_["x"] == 1
    assert locals_["y"] == 2
    assert "z" not in locals_  # Not defined yet
    
    # Continue to next breakpoint
    debugger.continue_execution()
    assert debugger.is_paused()
    assert debugger.current_line() == 5
    
    # Check locals again
    locals_ = debugger.get_locals()
    assert locals_["z"] == 3
    
    # Step over
    debugger.step_over()
    assert debugger.current_line() == 6
    
    # Check that a was set
    locals_ = debugger.get_locals()
    assert locals_["a"] == 6
    
    # Continue to end
    debugger.continue_execution()
    assert not debugger.is_paused()
```

## 21. Let's create a test for the language server's code actions:

```python
# tests/e2e/test_lsp_code_actions.py
import pytest
from hypercode.language_server import LanguageServer

def test_code_actions_imports():
    server = LanguageServer()
    
    # Initialize the server
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Open a document with an undefined variable
    server.handle_request({
        "jsonrpc": "2.0",
        "method": "textDocument/didOpen",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc",
                "languageId": "hypercode",
                "version": 1,
                "text": "let x = unknown_var"
            }
        }
    })
    
    # Get code actions for the error
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/codeAction",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "range": {
                "start": {"line": 0, "character": 8},
                "end": {"line": 0, "character": 19}
            },
            "context": {
                "diagnostics": [{
                    "range": {
                        "start": {"line": 0, "character": 8},
                        "end": {"line": 0, "character": 19}
                    },
                    "message": "Undefined variable 'unknown_var'",
                    "severity": 1
                }]
            }
        }
    })
    
    # Check that we got some code actions
    assert "result" in response
    assert isinstance(response["result"], list)
    assert len(response["result"]) > 0
    
    # Check that one of the actions is to import the variable
    action_titles = [action["title"] for action in response["result"]]
    assert any("Import" in title for title in action_titles)
```

## 22. Let's create a test for the formatter's configuration:

```python
# tests/e2e/test_formatter_config.py
from hypercode.formatter import format_code, FormatterConfig

def test_formatter_config():
    # Test with default config
    code = "let x=5;if(x>3){print('big')}else{print('small')}"
    formatted = format_code(code)
    assert "    " in formatted  # Default indentation is 4 spaces
    
    # Test with custom config
    config = FormatterConfig(indent_size=2, max_line_length=40)
    formatted = format_code(code, config=config)
    assert "  " in formatted  # Custom indentation of 2 spaces
    
    # Test line length
    long_code = "let long_variable_name = 'This is a very long string that should be wrapped to fit within the specified line length'"
    formatted = format_code(long_code, config=config)
    lines = formatted.split('\n')
    assert all(len(line) <= 40 for line in lines)

def test_formatter_preserves_semantics():
    # Test that formatting doesn't change the semantics of the code
    code = """
    func add(a,b){return a+b}
    let x=add(1,2)
    """
    
    # Format the code
    formatted = format_code(code)
    
    # The formatted code should produce the same result when executed
    interpreter = Interpreter()
    interpreter.interpret(code)
    original_result = interpreter.evaluate("x")
    
    interpreter = Interpreter()
    interpreter.interpret(formatted)
    formatted_result = interpreter.evaluate("x")
    
    assert original_result == formatted_result
```

## 23. Let's create a test for the documentation generator's markdown output:

```python
# tests/e2e/test_docs_markdown.py
from hypercode.docs.generator import generate_markdown_docs
import tempfile
import os

def test_markdown_docs_generation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a test module
        module_path = os.path.join(temp_dir, "math_utils.hc")
        with open(module_path, "w") as f:
            f.write("""
            /// Adds two numbers
            /// @param a First number
            /// @param b Second number
            /// @return Sum of a and b
            func add(a, b) {
                return a + b
            }
            
            /// Mathematical constant
            const PI = 3.14159
            """)
        
        # Generate markdown documentation
        output_file = os.path.join(temp_dir, "math_utils.md")
        generate_markdown_docs([module_path], output_file)
        
        # Verify documentation was generated
        assert os.path.exists(output_file)
        
        # Check the content
        with open(output_file) as f:
            content = f.read()
            assert "# math_utils" in content
            assert "## Functions" in content
            assert "### add(a, b)" in content
            assert "Adds two numbers" in content
            assert "## Constants" in content
            assert "### PI" in content
            assert "Mathematical constant" in content
```

## 24. Let's create a test for the REPL's tab completion:

```python
# tests/e2e/test_repl_completion.py
from hypercode.repl import REPL
from hypercode import Interpreter

def test_tab_completion():
    interpreter = Interpreter()
    repl = REPL(interpreter=interpreter)
    
    # Define some variables and functions
    interpreter.interpret("""
    let username = "hypercoder"
    let count = 42
    func greet(name) {
        return "Hello, " + name + "!"
    }
    class Counter {
        init() {
            this.value = 0
        }
        increment() {
            this.value += 1
            return this.value
        }
    }
    """)
    
    # Test variable completion
    completions = repl.get_completions("usern")
    assert "username" in completions
    
    # Test function completion
    completions = repl.get_completions("gree")
    assert "greet" in completions
    
    # Test method completion
    completions = repl.get_completions("let counter = Counter(); counter.incre")
    assert "increment" in completions
    
    # Test class completion
    completions = repl.get_completions("Count")
    assert "Counter" in completions
```

## 25. Let's create a test for the configuration system's validation:

```python
# tests/e2e/test_config_validation.py
import pytest
from hypercode.config import Config, ConfigValidationError
import tempfile
import json
import os

def test_config_validation():
    # Create a temporary config file with invalid values
    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
        config_data = {
            "editor": {
                "font_size": -1,  # Invalid, must be positive
                "theme": "invalid_theme"  # Not one of the allowed values
            }
        }
        json.dump(config_data, f)
        config_path = f.name
    
    try:
        # This should raise a validation error
        with pytest.raises(ConfigValidationError) as excinfo:
            config = Config(config_path)
        
        # Check that both validation errors are reported
        errors = str(excinfo.value).split('\n')
        assert any("font_size" in error for error in errors)
        assert any("theme" in error for error in errors)
        
    finally:
        if os.path.exists(config_path):
            os.unlink(config_path)

def test_config_defaults():
    # Test that default values are valid
    config = Config()  # No config file
    
    # These should not raise validation errors
    assert config.get("editor.font_size") > 0
    assert config.get("editor.theme") in ["light", "dark", "system"]
    
    # Test setting invalid values
    with pytest.raises(ConfigValidationError):
        config.set("editor.font_size", -1)
    
    with pytest.raises(ConfigValidationError):
        config.set("editor.theme", "invalid_theme")
```

## 26. Let's create a test for the package manager's version resolution:

```python
# tests/e2e/test_version_resolution.py
from hypercode.package_manager import VersionResolver
from hypercode.exceptions import VersionConflictError

def test_version_resolution():
    resolver = VersionResolver()
    
    # Test basic version comparison
    assert resolver.compare_versions("1.2.3", "1.2.3") == 0
    assert resolver.compare_versions("1.2.3", "1.2.4") < 0
    assert resolver.compare_versions("2.0.0", "1.9.9") > 0
    
    # Test version range matching
    assert resolver.matches_range("1.2.3", "^1.0.0") is True
    assert resolver.matches_range("2.0.0", "^1.0.0") is False
    assert resolver.matches_range("1.2.3", ">=1.0.0 <2.0.0") is True
    assert resolver.matches_range("2.0.0", ">=1.0.0 <2.0.0") is False
    
    # Test finding the best matching version
    available_versions = ["1.0.0", "1.1.0", "2.0.0", "2.1.0"]
    assert resolver.find_best_match("^1.0.0", available_versions) == "1.1.0"
    assert resolver.find_best_match(">=2.0.0", available_versions) == "2.1.0"
    
    # Test with no matching version
    assert resolver.find_best_match("^3.0.0", available_versions) is None

def test_dependency_resolution():
    resolver = VersionResolver()
    
    # Define a package with dependencies
    packages = {
        "pkg-a": {
            "1.0.0": {"dependencies": {"pkg-b": "^1.0.0"}},
            "2.0.0": {"dependencies": {"pkg-b": "^2.0.0"}}
        },
        "pkg-b": {
            "1.0.0": {},
            "1.1.0": {},
            "2.0.0": {},
            "2.1.0": {}
        }
    }
    
    # Test resolving dependencies
    result = resolver.resolve_dependencies({"pkg-a": "^1.0.0"}, packages)
    assert result["pkg-a"] == "1.0.0"
    assert result["pkg-b"] == "1.1.0"  # Should pick the highest compatible version
    
    # Test with a version conflict
    with pytest.raises(VersionConflictError):
        resolver.resolve_dependencies({
            "pkg-a": "^1.0.0",
            "pkg-b": "^2.0.0"
        }, packages)
```

## 27. Let's create a test for the plugin system's event handling:

```python
# tests/e2e/test_plugin_events.py
import pytest
from hypercode.plugins import PluginManager, Event

def test_plugin_event_handling():
    # Create a test plugin that tracks events
    class TestPlugin:
        def __init__(self):
            self.events_received = []
        
        def on_event(self, event, *args, **kwargs):
            self.events_received.append((event, args, kwargs))
    
    # Create plugin manager with test plugin
    plugin_manager = PluginManager()
    test_plugin = TestPlugin()
    plugin_manager.register_plugin(test_plugin)
    
    # Register event handlers
    @plugin_manager.on(Event.BEFORE_EXECUTE)
    def before_execute(code):
        return f"// Modified by plugin\n{code}"
    
    # Trigger events
    result = plugin_manager.trigger_event(Event.BEFORE_EXECUTE, "let x = 5")
    
    # Check that the plugin received the event
    assert len(test_plugin.events_received) == 1
    event, args, kwargs = test_plugin.events_received[0]
    assert event == Event.BEFORE_EXECUTE
    assert args[0] == "let x = 5"
    
    # Check that the event handler modified the code
    assert result == "// Modified by plugin\nlet x = 5"

def test_plugin_event_priority():
    # Test that plugins can set event priority
    results = []
    
    # Create plugin manager
    plugin_manager = PluginManager()
    
    # Register event handlers with different priorities
    @plugin_manager.on(Event.BEFORE_EXECUTE, priority=100)
    def high_priority(code):
        results.append("high")
        return code
    
    @plugin_manager.on(Event.BEFORE_EXECUTE, priority=10)
    def low_priority(code):
        results.append("low")
        return code
    
    # Trigger event
    plugin_manager.trigger_event(Event.BEFORE_EXECUTE, "test")
    
    # Check that higher priority handlers run first
    assert results == ["high", "low"]
```

## 28. Let's create a test for the debugger's variable inspection:

```python
# tests/e2e/test_debugger_variables.py
from hypercode.debugger import Debugger
from hypercode import Interpreter

def test_variable_inspection():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set a breakpoint
    debugger.set_breakpoint("test.hc", 4)
    
    # Run code that sets some variables
    code = """
    let x = 5  // line 1
    let y = {  // line 2
        name: "test",
        value: 42,
        nested: {  // line 5
            a: 1,
            b: 2
        }
    }
    let z = [1, 2, 3, {key: "value"}]  // line 10
    print(x, y, z)  // line 11 - breakpoint here
    """
    
    # Start execution (this would normally be in a separate thread)
    debugger.run(code, "test.hc")
    
    # Check that we're paused at the breakpoint
    assert debugger.is_paused()
    assert debugger.current_line() == 4
    
    # Get local variables
    locals_ = debugger.get_locals()
    assert "x" in locals_
    assert locals_["x"] == 5
    
    # Check object properties
    assert "y" in locals_
    y = locals_["y"]
    assert y["name"] == "test"
    assert y["value"] == 42
    
    # Check nested object
    assert "nested" in y
    assert y["nested"]["a"] == 1
    assert y["nested"]["b"] == 2
    
    # Check array
    assert "z" in locals_
    z = locals_["z"]
    assert isinstance(z, list)
    assert z[0] == 1
    assert z[1] == 2
    assert z[3]["key"] == "value"
    
    # Test evaluating expressions
    assert debugger.evaluate("x + y.value") == 47
    assert debugger.evaluate("y.name.upper()") == "TEST"
    assert debugger.evaluate("z.length") == 4
    
    # Continue execution
    debugger.continue_execution()
    assert not debugger.is_paused()
```

## 29. Let's create a test for the language server's hover information:

```python
# tests/e2e/test_lsp_hover.py
import pytest
from hypercode.language_server import LanguageServer

def test_hover_information():
    server = LanguageServer()
    
    # Initialize the server
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Open a document
    server.handle_request({
        "jsonrpc": "2.0",
        "method": "textDocument/didOpen",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc",
                "languageId": "hypercode",
                "version": 1,
                "text": """
                /// Adds two numbers
                /// @param a First number
                /// @param b Second number
                /// @return Sum of a and b
                func add(a, b) {
                    return a + b
                }
                
                let result = add(5, 3)
                """
            }
        }
    })
    
    # Get hover information for the 'add' function
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/hover",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "position": {
                "line": 7,  # Position of 'add' in the call
                "character": 25
            }
        }
    })
    
    # Check that we got hover information
    assert "result" in response
    assert "contents" in response["result"]
    
    # Check that the documentation is included
    contents = response["result"]["contents"]
    if isinstance(contents, dict):
        contents = contents["value"]
    assert "Adds two numbers" in contents
    assert "@param a First number" in contents
    assert "@return Sum of a and b" in contents

def test_hover_variable():
    server = LanguageServer()
    
    # Initialize the server
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Open a document with a variable
    server.handle_request({
        "jsonrpc": "2.0",
        "method": "textDocument/didOpen",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc",
                "languageId": "hypercode",
                "version": 1,
                "text": """
                /// A constant value
                const ANSWER = 42
                
                let x = ANSWER * 2
                """
            }
        }
    })
    
    # Get hover information for the 'ANSWER' constant
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/hover",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "position": {
                "line": 4,  # Position of 'ANSWER' in the expression
                "character": 25
            }
        }
    })
    
    # Check that we got hover information
    assert "result" in response
    assert "contents" in response["result"]
    
    # Check that the documentation is included
    contents = response["result"]["contents"]
    if isinstance(contents, dict):
        contents = contents["value"]
    assert "A constant value" in contents
    assert "const ANSWER = 42" in contents
```

## 30. Let's create a test for the formatter's code style rules:

```python
# tests/e2e/test_formatter_rules.py
from hypercode.formatter import format_code, FormatterConfig

def test_indentation():
    # Test that indentation is applied correctly
    code = """
if (true) {
let x=5
if(x>3){
print("big")
} else {
print("small")
}
}"""
    
    expected = """if true {
    let x = 5
    if x > 3 {
        print("big")
    } else {
        print("small")
    }
}"""
    
    formatted = format_code(code)
    assert formatted.strip() == expected.strip()

def test_spacing_around_operators():
    # Test spacing around operators
    code = "let x=1+2*3/4-5"
    expected = "let x = 1 + 2 * 3 / 4 - 5"
    assert format_code(code).strip() == expected

def test_braces():
    # Test brace placement
    code = """
if (x > 0)
{
    print("positive")
} else
{
    print("non-positive")
}"""
    
    expected = """if x > 0 {
    print("positive")
} else {
    print("non-positive")
}"""
    
    assert format_code(code).strip() == expected.strip()

def test_comma_separation():
    # Test comma separation in arrays and objects
    code = "let arr=[1,2,3,4]"
    expected = "let arr = [1, 2, 3, 4]"
    assert format_code(code).strip() == expected
    
    code = 'let obj={a:1,b:2,c:3}'
    expected = """let obj = {
    a: 1,
    b: 2,
    c: 3
}"""
    assert format_code(code).strip() == expected.strip()

def test_line_length():
    # Test line length limit
    code = 'let long_variable_name = "This is a very long string that should be wrapped to fit within the specified line length"'
    config = FormatterConfig(max_line_length=40)
    formatted = format_code(code, config=config)
    lines = formatted.split('\n')
    assert all(len(line) <= 40 for line in lines)
    assert '\\' in formatted  # Should have line continuation
```

## 31. Let's create a test for the documentation generator's API documentation:

```python
# tests/e2e/test_docs_api.py
from hypercode.docs.generator import generate_api_docs
import tempfile
import os

def test_api_documentation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a test module with API documentation
        module_path = os.path.join(temp_dir, "api.hc")
        with open(module_path, "w") as f:
            f.write("""
            /// This is a module-level docstring.
            /// It can span multiple lines.
            
            /// A constant value
            const VERSION = "1.0.0"
            
            /// A function that does something
            /// @param x The input value
            /// @return The processed result
            func process(x) {
                return x * 2
            }
            
            /// A class that represents a user
            class User {
                /// Create a new user
                /// @param name The user's name
                /// @param email The user's email
                init(name, email) {
                    this.name = name
                    this.email = email
                }
                
                /// Get a greeting message
                /// @return A greeting string
                greet() {
                    return "Hello, " + this.name + "!"
                }
            }
            """)
        
        # Generate API documentation
        output_dir = os.path.join(temp_dir, "api_docs")
        generate_api_docs([module_path], output_dir)
        
        # Verify documentation was generated
        assert os.path.exists(output_dir)
        assert os.path.exists(os.path.join(output_dir, "index.html"))
        assert os.path.exists(os.path.join(output_dir, "api.html"))
        
        # Check the content of the API documentation
        with open(os.path.join(output_dir, "api.html")) as f:
            content = f.read()
            
            # Check module docstring
            assert "This is a module-level docstring" in content
            
            # Check constant
            assert "VERSION" in content
            assert "A constant value" in content
            
            # Check function
            assert "process" in content
            assert "A function that does something" in content
            assert "@param x The input value" in content
            assert "@return The processed result" in content
            
            # Check class
            assert "class User" in content
            assert "A class that represents a user" in content
            
            # Check method
            assert "greet()" in content
            assert "Get a greeting message" in content
            assert "@return A greeting string" in content

def test_markdown_rendering():
    # Test that markdown in docstrings is rendered correctly
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a test module with markdown in docstrings
        module_path = os.path.join(temp_dir, "markdown.hc")
        with open(module_path, "w") as f:
            f.write('''
            /// # Markdown Test
            /// 
            /// This is a **bold** statement.
            /// 
            /// - Item 1
            /// - Item 2
            /// 
            /// ```javascript
            /// // Code example
            /// let x = 5;
            /// console.log(x * 2);
            /// ```
            func test() {
                // Function body
            }
            ''')
        
        # Generate documentation
        output_dir = os.path.join(temp_dir, "markdown_docs")
        generate_api_docs([module_path], output_dir)
        
        # Check that markdown was rendered
        with open(os.path.join(output_dir, "markdown.html")) as f:
            content = f.read()
            
            # Check that markdown was converted to HTML
            assert "<h1>Markdown Test</h1>" in content
            assert "<strong>bold</strong>" in content
            assert "<ul>" in content
            assert "<li>Item 1</li>" in content
            assert "<pre><code class=\"language-javascript\">" in content
```

## 32. Let's create a test for the REPL's command history navigation:

```python
# tests/e2e/test_repl_history_navigation.py
from hypercode.repl import REPL
from hypercode import Interpreter

def test_history_navigation():
    interpreter = Interpreter()
    repl = REPL(interpreter=interpreter)
    
    # Add some commands to history
    commands = [
        "let x = 5",
        "func add(a, b) { return a + b }",
        "print(add(x, 3))",
        "class Counter { init() { this.value = 0 } }",
        "let counter = Counter()"
    ]
    
    for cmd in commands:
        repl.add_to_history(cmd)
    
    # Test navigating history
    assert repl.get_previous_command() == "let counter = Counter()"
    assert repl.get_previous_command() == "class Counter { init() { this.value = 0 } }"
    assert repl.get_previous_command() == "print(add(x, 3))"
    
    # Test navigating forward
    assert repl.get_next_command() == "class Counter { init() { this.value = 0 } }"
    assert repl.get_next_command() == "let counter = Counter()"
    assert repl.get_next_command() == ""  # At the end of history
    
    # Test searching history
    matches = repl.search_history("count")
    assert len(matches) == 2
    assert "let counter = Counter()" in matches
    assert "class Counter" in matches[0]  # Most recent match first

def test_history_duplicates():
    interpreter = Interpreter()
    repl = REPL(interpreter=interpreter)
    
    # Add duplicate commands
    for _ in range(3):
        repl.add_to_history("let x = 5")
        repl.add_to_history("print(x)")
    
    # Should only keep one copy of each command
    history = repl.get_history()
    assert len(history) == 2
    assert history == ["let x = 5", "print(x)"]
    
    # Most recent duplicates should be kept
    repl.add_to_history("let x = 10")
    repl.add_to_history("let x = 5")  # This should move to the end
    history = repl.get_history()
    assert history == ["print(x)", "let x = 10", "let x = 5"]
```

## 33. Let's create a test for the configuration system's type conversion:

```python
# tests/e2e/test_config_types.py
import pytest
from hypercode.config import Config, ConfigType, ConfigValueError
import tempfile
import json
import os

def test_config_type_conversion():
    # Test automatic type conversion
    config = Config()
    
    # String values
    config.set("name", "HyperCode")
    assert config.get("name") == "HyperCode"
    assert isinstance(config.get("name"), str)
    
    # Integer values
    config.set("max_errors", "42")
    assert config.get("max_errors") == 42
    assert isinstance(config.get("max_errors"), int)
    
    # Float values
    config.set("threshold", "3.14")
    assert config.get("threshold") == 3.14
    assert isinstance(config.get("threshold"), float)
    
    # Boolean values
    for true_val in ["true", "True", "TRUE", "1", "yes", "on"]:
        config.set("enabled", true_val)
        assert config.get("enabled") is True
    
    for false_val in ["false", "False", "FALSE", "0", "no", "off"]:
        config.set("enabled", false_val)
        assert config.get("enabled") is False
    
    # Lists
    config.set("plugins", "['lint', 'format', 'test']")
    assert config.get("plugins") == ["lint", "format", "test"]
    assert isinstance(config.get("plugins"), list)
    
    # Dictionaries
    config.set("editor", '{"theme": "dark", "font_size": 14}')
    assert config.get("editor") == {"theme": "dark", "font_size": 14}
    assert isinstance(config.get("editor"), dict)

def test_explicit_types():
    # Test explicit type specification
    config = Config()
    
    # Register a setting with explicit type
    config.register_setting("max_workers", config_type=ConfigType.INTEGER, default=4)
    
    # Setting with correct type
    config.set("max_workers", "8")
    assert config.get("max_workers") == 8
    
    # Setting with invalid type
    with pytest.raises(ConfigValueError):
        config.set("max_workers", "eight")
    
    # Test enum type
    from enum import Enum
    class LogLevel(Enum):
        DEBUG = "debug"
        INFO = "info"
        WARNING = "warning"
        ERROR = "error"
    
    config.register_setting("log_level", config_type=ConfigType.ENUM, 
                          enum_type=LogLevel, default=LogLevel.INFO)
    
    # Valid enum value
    config.set("log_level", "debug")
    assert config.get("log_level") == LogLevel.DEBUG
    
    # Invalid enum value
    with pytest.raises(ConfigValueError):
        config.set("log_level", "verbose")

def test_config_validation_rules():
    # Test validation rules
    config = Config()
    
    # Register a setting with validation
    config.register_setting("port", 
                          config_type=ConfigType.INTEGER,
                          default=8080,
                          min_value=1024,
                          max_value=65535)
    
    # Valid value
    config.set("port", "3000")
    assert config.get("port") == 3000
    
    # Value too low
    with pytest.raises(ConfigValueError):
        config.set("port", "80")
    
    # Value too high
    with pytest.raises(ConfigValueError):
        config.set("port", "70000")
    
    # Test regex validation
    config.register_setting("username",
                          config_type=ConfigType.STRING,
                          default="user",
                          pattern=r"^[a-z][a-z0-9_-]{3,15}$")
    
    # Valid username
    config.set("username", "hypercode")
    assert config.get("username") == "hypercode"
    
    # Invalid username
    with pytest.raises(ConfigValueError):
        config.set("username", "2cool")  # Starts with a number
```

## 34. Let's create a test for the package manager's installation process:

```python
# tests/e2e/test_package_installation.py
import pytest
from hypercode.package_manager import PackageManager
from hypercode.exceptions import PackageNotFoundError, VersionConflictError
import tempfile
import os
import shutil

def test_package_installation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a package manager with a temporary directory
        pm = PackageManager(package_dir=temp_dir)
        
        # Mock package repository
        class MockRepository:
            def get_package_versions(self, name):
                if name == "test-package":
                    return ["1.0.0", "1.1.0", "2.0.0"]
                return []
            
            def download_package(self, name, version, target_dir):
                # Create a mock package
                os.makedirs(target_dir, exist_ok=True)
                with open(os.path.join(target_dir, "package.json"), "w") as f:
                    json.dump({
                        "name": name,
                        "version": version,
                        "main": "index.js"
                    }, f)
                with open(os.path.join(target_dir, "index.js"), "w") as f:
                    f.write(f"// {name} v{version}\n")
        
        pm.repository = MockRepository()
        
        # Install a package
        pm.install("test-package", "1.1.0")
        
        # Verify the package was installed
        package_dir = os.path.join(temp_dir, "test-package-1.1.0")
        assert os.path.exists(package_dir)
        assert os.path.exists(os.path.join(package_dir, "package.json"))
        assert os.path.exists(os.path.join(package_dir, "index.js"))
        
        # Verify the package is in the index
        assert "test-package" in pm.list_installed()
        assert pm.get_installed_version("test-package") == "1.1.0"
        
        # Test installing a different version
        with pytest.raises(VersionConflictError):
            pm.install("test-package", "2.0.0")
        
        # Test force install
        pm.install("test-package", "2.0.0", force=True)
        assert pm.get_installed_version("test-package") == "2.0.0"
        
        # Test uninstalling
        pm.uninstall("test-package")
        assert "test-package" not in pm.list_installed()
        assert not os.path.exists(package_dir)

def test_dependency_installation():
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create a package manager with a temporary directory
        pm = PackageManager(package_dir=temp_dir)
        
        # Mock package repository with dependencies
        class MockRepository:
            def get_package_versions(self, name):
                versions = {
                    "test-package": ["1.0.0"],
                    "dep-a": ["1.0.0"],
                    "dep-b": ["2.0.0"]
                }
                return versions.get(name, [])
            
            def get_package_metadata(self, name, version):
                if name == "test-package" and version == "1.0.0":
                    return {
                        "name": "test-package",
                        "version": "1.0.0",
                        "dependencies": {
                            "dep-a": "^1.0.0",
                            "dep-b": "^2.0.0"
                        }
                    }
                return {"name": name, "version": version}
            
            def download_package(self, name, version, target_dir):
                os.makedirs(target_dir, exist_ok=True)
                with open(os.path.join(target_dir, "package.json"), "w") as f:
                    json.dump({
                        "name": name,
                        "version": version
                    }, f)
        
        pm.repository = MockRepository()
        
        # Install a package with dependencies
        pm.install("test-package", "1.0.0")
        
        # Verify the package and its dependencies were installed
        assert pm.is_installed("test-package")
        assert pm.is_installed("dep-a")
        assert pm.is_installed("dep-b")
        
        # Verify the dependency versions
        assert pm.get_installed_version("dep-a") == "1.0.0"
        assert pm.get_installed_version("dep-b") == "2.0.0"

def test_package_not_found():
    with tempfile.TemporaryDirectory() as temp_dir:
        pm = PackageManager(package_dir=temp_dir)
        
        # Mock repository that doesn't have the package
        class MockRepository:
            def get_package_versions(self, name):
                return []
        
        pm.repository = MockRepository()
        
        # Try to install a non-existent package
        with pytest.raises(PackageNotFoundError):
            pm.install("non-existent-package", "1.0.0")
```

## 35. Let's create a test for the plugin system's extension points:

```python
# tests/e2e/test_plugin_extensions.py
import pytest
from hypercode.plugins import PluginManager, ExtensionPoint
from hypercode.events import Event

def test_extension_points():
    # Create a plugin manager
    plugin_manager = PluginManager()
    
    # Define an extension point
    formatters = ExtensionPoint("formatters", "Code formatters")
    plugin_manager.register_extension_point(formatters)
    
    # Create a plugin that extends the formatters extension point
    class FormatterPlugin:
        def __init__(self):
            self.name = "my-formatter"
        
        def format(self, code):
            return f"// Formatted by {self.name}\n{code}"
    
    # Register the plugin's formatter
    formatter = FormatterPlugin()
    plugin_manager.register_extension("formatters", formatter)
    
    # Get all formatters
    formatters = plugin_manager.get_extensions("formatters")
    assert len(formatters) == 1
    assert formatters[0].name == "my-formatter"
    
    # Test the formatter
    code = "let x=5"
    formatted = formatters[0].format(code)
    assert "// Formatted by my-formatter" in formatted
    assert "let x = 5" in formatted

def test_plugin_lifecycle():
    # Test plugin initialization and cleanup
    class TestPlugin:
        def __init__(self):
            self.initialized = False
            self.cleanup_called = False
        
        def initialize(self):
            self.initialized = True
        
        def cleanup(self):
            self.cleanup_called = True
    
    # Create and register the plugin
    plugin_manager = PluginManager()
    test_plugin = TestPlugin()
    plugin_manager.register_plugin(test_plugin)
    
    # Initialize plugins
    plugin_manager.initialize_plugins()
    assert test_plugin.initialized is True
    
    # Clean up plugins
    plugin_manager.cleanup_plugins()
    assert test_plugin.cleanup_called is True

def test_plugin_dependencies():
    # Test plugin dependencies
    class DatabasePlugin:
        def __init__(self):
            self.connected = False
        
        def connect(self):
            self.connected = True
    
    class UserPlugin:
        def __init__(self, database):
            self.database = database
            self.initialized = False
        
        def initialize(self):
            if not self.database.connected:
                self.database.connect()
            self.initialized = True
    
    # Create plugin manager
    plugin_manager = PluginManager()
    
    # Register plugins
    db_plugin = DatabasePlugin()
    user_plugin = UserPlugin(db_plugin)
    
    plugin_manager.register_plugin(db_plugin)
    plugin_manager.register_plugin(user_plugin)
    
    # Initialize plugins (should handle dependencies)
    plugin_manager.initialize_plugins()
    
    # Verify both plugins were initialized correctly
    assert db_plugin.connected is True
    assert user_plugin.initialized is True
    assert user_plugin.database is db_plugin  # Same instance
```

## 36. Let's create a test for the debugger's breakpoint conditions:

```python
# tests/e2e/test_debugger_conditions.py
from hypercode.debugger import Debugger
from hypercode import Interpreter

def test_conditional_breakpoints():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set a conditional breakpoint
    debugger.set_breakpoint("test.hc", 5, condition="x > 5")
    
    # Run code that will hit the breakpoint conditionally
    code = """
    let x = 0  // line 1
    while x < 10 {  // line 2
        x = x + 1  // line 3
        print(x)  // line 4
        // line 5 - conditional breakpoint here
    }
    """
    
    # Start execution
    debugger.run(code, "test.hc")
    
    # The breakpoint should trigger when x > 5
    assert debugger.is_paused()
    
    # Check the value of x
    locals_ = debugger.get_locals()
    assert locals_["x"] == 6  # First iteration where x > 5
    
    # Continue execution
    debugger.continue_execution()
    
    # The breakpoint should trigger again on the next iteration
    assert debugger.is_paused()
    locals_ = debugger.get_locals()
    assert locals_["x"] == 7
    
    # Disable the breakpoint
    debugger.toggle_breakpoint("test.hc", 5, enabled=False)
    
    # Continue execution - should run to completion
    debugger.continue_execution()
    assert not debugger.is_paused()

def test_logpoint():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set a logpoint
    debugger.set_breakpoint("test.hc", 3, log_message="x is now {x}")
    
    # Capture stdout
    import io
    import sys
    old_stdout = sys.stdout
    sys.stdout = io.StringIO()
    
    try:
        # Run code that will hit the logpoint
        code = """
        let x = 1  // line 1
        x = x * 2  // line 2
        x = x + 1  // line 3 - logpoint here
        print("Done")
        """
        
        debugger.run(code, "test.hc")
        
        # Check that the log message was printed
        output = sys.stdout.getvalue()
        assert "x is now 3" in output
        assert "Done" in output  # Make sure execution continued
        
    finally:
        # Restore stdout
        sys.stdout = old_stdout

def test_hit_count_breakpoint():
    interpreter = Interpreter()
    debugger = Debugger(interpreter)
    
    # Set a breakpoint that triggers every 3rd hit
    debugger.set_breakpoint("test.hc", 3, hit_count=3)
    
    # Run code with a loop
    code = """
    let sum = 0  // line 1
    for i in 1..10 {  // line 2
        sum = sum + i  // line 3 - breakpoint here
    }
    """
    
    debugger.run(code, "test.hc")
    
    # The breakpoint should trigger when i is 3, 6, and 9
    assert debugger.is_paused()
    locals_ = debugger.get_locals()
    assert locals_["i"] == 3
    assert locals_["sum"] == 6  # 1 + 2 + 3
    
    # Continue to next hit
    debugger.continue_execution()
    assert debugger.is_paused()
    locals_ = debugger.get_locals()
    assert locals_["i"] == 6
    assert locals_["sum"] == 21  # 1+2+3+4+5+6
    
    # Continue to last hit
    debugger.continue_execution()
    assert debugger.is_paused()
    locals_ = debugger.get_locals()
    assert locals_["i"] == 9
    assert locals_["sum"] == 45  # 1+2+...+9
    
    # Continue to end
    debugger.continue_execution()
    assert not debugger.is_paused()
```

## 37. Let's create a test for the language server's code actions:

```python
# tests/e2e/test_lsp_code_actions.py
import pytest
from hypercode.language_server import LanguageServer

def test_quick_fix_code_actions():
    server = LanguageServer()
    
    # Initialize the server
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Open a document with an undefined variable
    server.handle_request({
        "jsonrpc": "2.0",
        "method": "textDocument/didOpen",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc",
                "languageId": "hypercode",
                "version": 1,
                "text": """
                function calculate() {
                    let result = someUndefinedVar + 5
                    return result
                }
                """
            }
        }
    })
    
    # Get code actions for the error
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/codeAction",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "range": {
                "start": {"line": 2, "character": 30},
                "end": {"line": 2, "character": 45}
            },
            "context": {
                "diagnostics": [{
                    "range": {
                        "start": {"line": 2, "character": 30},
                        "end": {"line": 2, "character": 45}
                    },
                    "message": "Undefined variable 'someUndefinedVar'",
                    "severity": 1
                }]
            }
        }
    })
    
    # Check that we got some code actions
    assert "result" in response
    assert isinstance(response["result"], list)
    assert len(response["result"]) > 0
    
    # Check that one of the actions is to declare the variable
    action_titles = [action["title"] for action in response["result"]]
    assert any("Declare variable" in title for title in action_titles)
    
    # Apply the "Declare variable" action
    declare_action = next(
        action for action in response["result"]
        if "Declare variable" in action["title"]
    )
    
    # Apply the edit
    edit_params = {
        "textDocument": {
            "uri": "file:///project/test.hc",
            "version": 1
        },
        "edits": declare_action["edit"]["changes"]["file:///project/test.hc"]
    }
    
    edit_response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 3,
        "method": "workspace/applyEdit",
        "params": {
            "label": "Declare variable",
            "edit": {
                "changes": {
                    "file:///project/test.hc": edit_params["edits"]
                }
            }
        }
    })
    
    # Check that the edit was applied
    assert "applied" in edit_response.get("result", {})
    assert edit_response["result"]["applied"] is True
    
    # Get the updated document
    document_response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 4,
        "method": "textDocument/documentSymbol",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            }
        }
    })
    
    # The variable should now be declared at the top of the function
    assert "result" in document_response
    symbols = document_response["result"]
    assert any(symbol["name"] == "someUndefinedVar" for symbol in symbols)

def test_refactor_extract_function():
    server = LanguageServer()
    
    # Initialize the server
    server.handle_request({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "processId": 1234,
            "rootPath": "/project",
            "capabilities": {}
        }
    })
    
    # Open a document with code to refactor
    server.handle_request({
        "jsonrpc": "2.0",
        "method": "textDocument/didOpen",
        "params": {
            "textDocument": {
  "uri": "file:///project/test.hc",
                "languageId": "hypercode",
                "version": 1,
                "text": "function processData(data) {\n  // Calculate the sum\n  let sum = 0;\n  for (let i = 0; i < data.length; i++) {\n    sum += data[i];\n  }\n  \n  // Calculate the average\n  let average = sum / data.length;\n  \n  // Filter values above average\n  let result = [];\n  for (let i = 0; i < data.length; i++) {\n    if (data[i] > average) {\n      result.push(data[i]);\n    }\n  }\n  \n  return result;\n}"
            }
        }
    })
    
    # Get code actions for refactoring
    response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "textDocument/codeAction",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            },
            "range": {
                "start": {
                    "line": 2,
                    "character": 2
                },
                "end": {
                    "line": 5,
                    "character": 3
                }
            },
            "context": {
                "only": ["refactor.extract"]
            }
        }
    })
    
    # Check that we got some code actions
    assert "result" in response
    assert isinstance(response["result"], list)
    assert len(response["result"]) > 0
    
    # Check that one of the actions is to extract a function
    action_titles = [action["title"] for action in response["result"]]
    assert any("Extract function" in title for title in action_titles)
    
    # Apply the "Extract function" action
    extract_action = next(
        action for action in response["result"]
        if "Extract function" in action["title"]
    )
    
    # Apply the edit
    edit_params = {
        "textDocument": {
            "uri": "file:///project/test.hc",
            "version": 1
        },
        "edits": extract_action["edit"]["changes"]["file:///project/test.hc"]
    }
    
    edit_response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 3,
        "method": "workspace/applyEdit",
        "params": {
            "label": "Extract function",
            "edit": {
                "changes": {
                    "file:///project/test.hc": edit_params["edits"]
                }
            }
        }
    })
    
    # Check that the edit was applied
    assert "applied" in edit_response.get("result", {})
    assert edit_response["result"]["applied"] is True
    
    # Get the updated document
    document_response = server.handle_request({
        "jsonrpc": "2.0",
        "id": 4,
        "method": "textDocument/documentSymbol",
        "params": {
            "textDocument": {
                "uri": "file:///project/test.hc"
            }
        }
    })
    
    # The new function should now exist
    assert "result" in document_response
    symbols = document_response["result"]
    assert any(symbol["kind"] == 12 and "newFunction" in symbol["name"] for symbol in symbols) # 12 is Function