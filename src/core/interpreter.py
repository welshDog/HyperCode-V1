"""
HyperCode Interpreter

This module implements the interpreter for the HyperCode language, which executes
the abstract syntax tree (AST) generated by the parser.
"""

import time
from typing import Any, List, Dict, Optional
from .ast import (
    Stmt, Expr, Expression, Print, Var, Block, Assign, Binary, Grouping,
    Literal, Unary, Variable, If, Fun, Return, Call, Intent, Function as FunctionStmt
)
from .tokens import Token, TokenType


class ReturnException(Exception):
    """Exception raised for return statements in functions."""
    
    def __init__(self, value: Any) -> None:
        """Initialize with the return value."""
        self.value = value
        super().__init__()


class HyperCodeCallable:
    """Base class for callable objects in HyperCode."""
    
    def arity(self) -> int:
        """Return the number of parameters the callable accepts."""
        raise NotImplementedError()
    
    def call(self, interpreter: 'Interpreter', arguments: List[Any]) -> Any:
        """Call the function with the given arguments."""
        raise NotImplementedError()


class HyperCodeFunction(HyperCodeCallable):
    """Represents a function in HyperCode."""
    
    def __init__(self, declaration: FunctionStmt, closure: 'Environment') -> None:
        """Initialize with function declaration and closure."""
        self.declaration = declaration
        self.closure = closure

    def __str__(self) -> str:
        """Return a string representation of the function."""
        return f"<fn {self.declaration.name.lexeme}>"

    def arity(self) -> int:
        """Return the number of parameters the function accepts."""
        return len(self.declaration.params)

    def call(self, interpreter: 'Interpreter', arguments: List[Any]) -> Any:
        """Call the function with the given arguments."""
        environment = Environment(self.closure)
        
        # Define parameters in the new environment
        for i, param in enumerate(self.declaration.params):
            environment.define(param.lexeme, arguments[i])

        try:
            interpreter.execute_block(self.declaration.body, environment)
        except ReturnException as return_value:
            return return_value.value

        return None


class Clock(HyperCodeCallable):
    """Native clock function that returns current time."""
    
    def arity(self) -> int:
        return 0
    
    def call(self, interpreter: 'Interpreter', arguments: List[Any]) -> float:
        return time.time()
    
    def __str__(self) -> str:
        return "<native fn clock>"


class Environment:
    """Manages variable scopes and lookups in the interpreter."""
    
    def __init__(self, enclosing: Optional['Environment'] = None) -> None:
        """Initialize a new environment with an optional enclosing scope."""
        self.values: Dict[str, Any] = {}
        self.enclosing = enclosing

    def define(self, name: str, value: Any) -> None:
        """Define a variable in the current scope."""
        self.values[name] = value

    def get(self, name: str) -> Any:
        """Get the value of a variable, checking parent scopes if not found."""
        if name in self.values:
            return self.values[name]
        if self.enclosing is not None:
            return self.enclosing.get(name)
        raise RuntimeError(f"Undefined variable '{name}'")

    def assign(self, name: str, value: Any) -> None:
        """Assign a value to a variable in the current or enclosing scope."""
        if name in self.values:
            self.values[name] = value
        elif self.enclosing is not None:
            self.enclosing.assign(name, value)
        else:
            raise RuntimeError(f"Undefined variable '{name}'")


class Interpreter:
    """Interprets and executes HyperCode programs."""
    
    def __init__(self) -> None:
        """Initialize the interpreter with global and local environments."""
        self.globals = Environment()
        self.environment = self.globals
        self.output: List[str] = []
        self.locals: Dict[Expr, int] = {}
        
        # Define native functions
        self.globals.define("clock", Clock())

    def interpret(self, statements: List[Stmt]) -> None:
        """Interpret a list of statements."""
        try:
            for statement in statements:
                self.execute(statement)
        except RuntimeError as e:
            print(f"âŒ Runtime error: {e}")

    def execute(self, stmt: Stmt) -> None:
        """Execute a single statement."""
        stmt.accept(self)

    def execute_block(self, statements: List[Stmt], environment: Environment) -> None:
        """Execute a block of statements in the given environment."""
        previous = self.environment
        try:
            self.environment = environment
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous

    def evaluate(self, expr: Expr) -> Any:
        """Evaluate an expression and return its value."""
        return expr.accept(self)

    # Statement visitors
    def visit_Expression(self, stmt: Expression) -> None:
        """Visit an expression statement."""
        self.evaluate(stmt.expression)

    def visit_Print(self, stmt: Print) -> None:
        """Visit a print statement."""
        value = self.evaluate(stmt.expression)
        output = self.stringify(value)
        self.output.append(output)
        print(output)

    def visit_Var(self, stmt: Var) -> None:
        """Visit a variable declaration statement."""
        value = None
        if stmt.initializer:
            value = self.evaluate(stmt.initializer)
        self.environment.define(stmt.name.value, value)

    def visit_Block(self, stmt: Block) -> None:
        """Visit a block statement."""
        self.execute_block(stmt.statements, Environment(self.environment))

    def visit_Intent(self, stmt: Intent) -> None:
        """Visit an intent statement."""
        for statement in stmt.statements:
            self.execute(statement)

    def visit_Function(self, stmt: FunctionStmt) -> None:
        """Visit a function declaration statement."""
        function = HyperCodeFunction(stmt, self.environment)
        self.environment.define(stmt.name.lexeme, function)

    def visit_Return(self, stmt: Return) -> None:
        """Visit a return statement."""
        value = None
        if stmt.value is not None:
            value = self.evaluate(stmt.value)
        raise ReturnException(value)

    # Expression visitors
    def visit_Literal(self, expr: Literal) -> Any:
        """Visit a literal expression."""
        return expr.value

    def visit_Grouping(self, expr: Grouping) -> Any:
        """Visit a grouping expression."""
        return self.evaluate(expr.expression)

    def visit_Variable(self, expr: Variable) -> Any:
        """Visit a variable expression."""
        return self.environment.get(expr.name.value)

    def visit_Assign(self, expr: Assign) -> Any:
        """Visit an assignment expression."""
        value = self.evaluate(expr.value)
        self.environment.assign(expr.name.value, value)
        return value

    def visit_Call(self, expr: Call) -> Any:
        """Visit a function call expression."""
        callee = self.evaluate(expr.callee)
        
        arguments = []
        for argument in expr.arguments:
            arguments.append(self.evaluate(argument))
        
        if not isinstance(callee, HyperCodeCallable):
            raise RuntimeError("Can only call functions and classes.")
        
        if len(arguments) != callee.arity():
            raise RuntimeError(
                f"Expected {callee.arity()} arguments but got {len(arguments)}."
            )
        
        return callee.call(self, arguments)

    def visit_Binary(self, expr: Binary) -> Any:
        """Visit a binary expression."""
        left = self.evaluate(expr.left)
        right = self.evaluate(expr.right)
        op_type = expr.operator.token_type
        
        if op_type == TokenType.PLUS:
            if isinstance(left, str) or isinstance(right, str):
                return str(left) + str(right)
            return left + right
        elif op_type == TokenType.MINUS:
            return left - right
        elif op_type == TokenType.STAR:
            return left * right
        elif op_type == TokenType.SLASH:
            if right == 0:
                raise RuntimeError("Division by zero")
            return left / right
        elif op_type == TokenType.GREATER:
            return left > right
        elif op_type == TokenType.GREATER_EQUAL:
            return left >= right
        elif op_type == TokenType.LESS:
            return left < right
        elif op_type == TokenType.LESS_EQUAL:
            return left <= right
        elif op_type == TokenType.EQUAL_EQUAL:
            return left == right
        elif op_type == TokenType.BANG_EQUAL:
            return left != right
        
        return None

    def visit_Unary(self, expr: Unary) -> Any:
        """Visit a unary expression."""
        right = self.evaluate(expr.right)
        
        if expr.operator.token_type == TokenType.MINUS:
            return -right
        elif expr.operator.token_type == TokenType.BANG:
            return not self.is_truthy(right)
        
        return None

    # Helper methods
    def is_truthy(self, value: Any) -> bool:
        """Check if a value is truthy in HyperCode."""
        if value is None:
            return False
        if isinstance(value, bool):
            return value
        return True

    def stringify(self, value: Any) -> str:
        """Convert a value to its string representation."""
        if value is None:
            return "nil"
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, float):
            text = str(value)
            if text.endswith(".0"):
                text = text[:-2]
            return text
        return str(value)

    def get_output(self) -> str:
        """Get all output generated during interpretation."""
        return "\n".join(self.output)
